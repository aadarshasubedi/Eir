TODO
- use state machine to :
  - move sprite when player use pad
  - move sprite when player use keyboard
- (MACRO) display using real size => ortho projection and matrix + camera
  - add matrix struct
  - add matrix mult
  - add matrix ortho projection
  - add AABB struct in phyics part
    - position
    - size
  - add camera window struct in camera part
    - AABB target (pointer)
    - window AABB
  - add viewport struct in graphics part
  - add camera struct in camera part
    - projection matrix
    - camera window
    - position
    - window last position
    - view matrix
    - mvp matrix
    - viewport
  - camera window follow player if player exit window
  - camera follow window
- (MACRO) AI follow

DONE
+ use TestOpengl skeleton project move to C language
+ display two textured quads
+ create function to add sprite in sprite batch in main.c
+ move code that can be moved in dedicated file
+ splite code in core function and api function in main.c for all graphics tasks
+ move all graphics core and api functions in dedicated files
+ add timer for elapsed time
+ set batch as dynamic
+ move sprite 1 position in batch following elapsed time
+ see if update data buffer is needed (we need it !)
+ remove position change following time
+ add joypad init
+ get joypad axis move
+ move sprite position following elapsed time and joypad axis offset
+ get sound for test
+ call to sound load function before loop
+ play sound when moving
+ add sprite size parameter
+ add array macro
+ replace batch [] in gfx env with new array
+ add built attribute in batch struct
+ call to build batch in loop if built attribute is false
+ add modified attribute in batch struct
+ call to set buffer data in loop only if modified attribute is true
+ regression test on moving sprite with keyboard and/or joystick
+ add array for sound in snd env
+ add color parameter for sprite.
+ use it in shaders.
+ add eir_handle_t typedef (int) for all object creation interface with user
  + sprite
  + sprite batch
  + sound
+ review object creation interface (sprite, sprite batch, sound)
+ text display (see old code)
+ display frame duration
  + create update text method
  + calculate frame duration
  + display frame duration
+ display line
+ log pointers not free at the end of the program
  + create static list of allocation
  + add allocated pointer in the allocation
  + delete free pointer
  + display list at the end of the program
  + see if we must create a macro to have function/file/line etc.
+ display quad fill
+ add euler integration for acceleration/velocity moves
+ check validity move
+ check for user allocation and free function
  + if not set => used default one
  + if set => nothing to do
  + check before first env struct creation
+ (MACRO) implement state machine for input ctrl
  + move all struct from eir_input_ctrl.h to eir.h
  + remove the _sys prefix from these structures
  + remove eir_input_ctrl.h and change references to it with eir.h
  + add validation function pointer declaration in eir.h
  + add update function pointer declaration in eir.h
  + create state struct in eir_gme_state_machine.h
    + add function pointer to validate state entry
    + add function pointer to update state
    + add list on linked out states
  + create state machine struct in eir_gme_state_machine.h
    + add begining state pointer
    + add ending state pointer
    + add current state pointer
    + add all state machines states
  + add state machine array in eir_fsm_env struct
  + add current state machine pointer in eir_fsm_env strut
  + create function to create state machine in eir.h
    + add parameter max state count
    + return state machine handle
  + create function to create state in eir.h
    + return state machine handle
  + create function to register state entry validation function for specified state in eir.h
    + add state handle parameter
    + add function pointer
    + return result as bool
  + create function to register update state function for specified state in eir.h
    + add state handle parameter
    + add function pointer
    + return result as bool
  + create function to register linked state in eir.h
    + add in state handle
    + add out state handle
    + return result as bool
  + create function to register state in state machine in eir.h
    + add state machine handle parameter
    + add state handle parameter
    + add bool is_begin_state parameter
    + add bool is_end_state parameter
    + return result as bool
  + create function to run start machine in eir_gme_state_machine.h
    + add state machine handle parameter
  + create function to update state machine in eir_gme_state_machine.h
    + add state machine handle parameter
  + create function to stop state machine in eir_gme_state_machine.h
    + add state machine handle parameter
  + create function to destroy state machine in eir_gme_state_machine.h
    + add state machine handle parameter
  + injection event in state machine ???
+ add commit message parameter for commit script as $1